"""Pipeline to compute data for power spectral density of Buccino's model
takes 1h20 min, for 10 minutes recording

Usage:

    sbatch cluster/validation/main/buccino/psd/full/psd_buttw_raw_welch_gain_ftd.sbatch

Description:

- take first 10 mins
- compress to int16 and save
- calculate and save Welch PSD

Returns:
    _type_: _description_
"""

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.filterwarnings("ignore")

import os
import numpy as np
import spikeinterface as si
from concurrent.futures import ProcessPoolExecutor
from scipy import signal
import spikeinterface.preprocessing as spre

# move to PROJECT PATH
PROJ_PATH = "/gpfs/bbp.cscs.ch/project/proj85/home/laquitai/spikebias/"
os.chdir(PROJ_PATH)

from src.nodes.utils import get_config

# pipeline
COMPUTE_PSD = True

# SETUP PARAMETERS
SFREQ_BUCCI = 32000
SFREQ_VIVO = 30000

# welch PSD plots
FILT_WINDOW = "hann"
FILT_WIND_SIZE_bucci = 32000 # 1Hz freq. resol
FILT_WIND_OVERLAP_bucci = int(
    FILT_WIND_SIZE_bucci // 1.5
)

# SETUP DATASET CONFIG
# vivo
data_conf_vivo, param_conf_h_vivo = get_config("vivo_marques", "c26").values()
RAW_PATH_vivo = data_conf_vivo["probe_wiring"]["output"]
PREP_PATH_vivo = data_conf_vivo["preprocessing"]["output"]["trace_file_path"]

# buccino
data_conf_bucci, param_conf_bucci = get_config(
    "buccino_2020", "2020"
).values()
RAW_PATH_bucci = data_conf_bucci["probe_wiring"]["output"]
PREP_PATH_bucci = data_conf_bucci["preprocessing"]["output"]["trace_file_path"]
WIRED_FITD_INT16_PATH = data_conf_bucci["probe_wiring"]["10m"]["output_gain_fitd_int16"]
RAW_GAIN_FTD_PATH = data_conf_bucci["analyses"]["psd"]["10m"]["raw_gain_ftd"]
PREP_GAIN_FTD_PATH = data_conf_bucci["analyses"]["psd"]["10m"]["prep_gain_ftd"]
FITTING_GAIN_PATH = data_conf_bucci["preprocessing"]["fitting"]["gain"]


def get_welch_psd_parallelized(traces: np.ndarray):
    """compute power spectrum density
    using parallel computing

    Args:
        traces (np.ndarray): timepoints x sites voltage traces

    Returns:
        dict: frequencies x sites powers arraay and frequencies array
    """
    # takes 2 min (instead of 70 min w/o multiprocessing)
    nsites = traces.shape[1]

    # compute power for each site trace
    # in parallel with a pool of workers
    with ProcessPoolExecutor() as executor:
        power_by_site = executor.map(
            get_site_welch_psd,
            traces.T,
            np.arange(0, nsites, 1),
        )
    power_by_sites = list(power_by_site)

    # make an array with powers
    powersd = []
    for site in range(nsites):
        powersd.append(power_by_sites[site][0])
    powers = np.array(powersd)

    # store frequency domain
    freqs = power_by_sites[0][1]
    return {"power": powers, "freq": freqs}


def get_site_welch_psd(trace, site):
    """calculate the welch frequency powers in the input trace

    Args:
        traces (np.ndarray): timepoints x sites voltage trace
        SFREQ_BUCCI(_type_): voltage trace sampling frequency
        site: silent, automatically generated by ProcessPoolExecutor()

    Returns:
        _type_: _description_
    """
    (freq, power) = signal.welch(
        trace,
        SFREQ_BUCCI,
        window=FILT_WINDOW,
        nperseg=FILT_WIND_SIZE_bucci,
        noverlap=FILT_WIND_OVERLAP_bucci,
    )
    return np.array(power), np.array(freq)

# Calculate fitting gain  *******************************************

# max absolute amplitude in layer 5 for raw vivo
raw_vivo = si.load_extractor(RAW_PATH_vivo)
raw_vivo = spre.astype(raw_vivo, "int16")
l5 = raw_vivo.get_property("layers") == "L5"
max_vivo = np.max(np.absolute(raw_vivo.get_traces(channel_ids=l5)))
print("max absolute amplitude in vivo L5:", max_vivo)

# max absolute amplitude in raw Buccino (layer 5)
raw_bucci = si.load_extractor(RAW_PATH_bucci)
raw_bucci_10m = raw_bucci.frame_slice(start_frame=0, end_frame=10 * 60 * SFREQ_BUCCI)
raw_bucci_10m = spre.astype(raw_bucci_10m, "int16")
traces = raw_bucci_10m.get_traces()
max_bucci = np.max(np.absolute(traces))
print("max absolute amplitude buccino:", max_bucci)

# calculate gain
fitting_gain = max_vivo / max_bucci
print("fitting gain:", fitting_gain)
np.save(FITTING_GAIN_PATH, fitting_gain)

# FITTING GAIN  *******************************************

# - load traces 
# - select the first 10 minutes
# - compress from floats to integers
# - apply gain to match in vivo max amplitude
# - preprocess
# - compress to int16
RawSili = si.load_extractor(RAW_PATH_bucci)
RawSili = RawSili.frame_slice(start_frame=0, end_frame=SFREQ_BUCCI * 10 * 60)
RawSili = spre.scale(RawSili, fitting_gain)
RawSili = spre.astype(RawSili, "int16")
RawSili.save(
    folder=WIRED_FITD_INT16_PATH,
    format="binary",
    n_jobs=4,
    chunk_memory="40G",
    overwrite=True,
    progress_bar=True
)
PreSili = spre.bandpass_filter(
    RawSili, freq_min=300, freq_max=SFREQ_BUCCI / 2 - 1
)
PreSili = spre.common_reference(
    PreSili, reference="global", operator="median"
)
PreSili = spre.astype(PreSili, "int16")

# get traces 
raw_traces_sili_ftd = RawSili.get_traces()
prep_traces_sili_ftd = PreSili.get_traces()

# PSD *******************************************************

# fitted gain
out_raw_sili_ftd = get_welch_psd_parallelized(raw_traces_sili_ftd)
out_prep_sili_ftd = get_welch_psd_parallelized(prep_traces_sili_ftd)

# SAVE PSDS *******************************************************
os.makedirs(
    "/gpfs/bbp.cscs.ch/project/proj85/laquitai/spikebias_paper/postprocessing/hybrid/buccino/realism/lfp/",
    exist_ok=True,
)    

# save PSD for fitting gain
np.save(RAW_GAIN_FTD_PATH, out_raw_sili_ftd)
np.save(PREP_GAIN_FTD_PATH, out_prep_sili_ftd)