# """Pipeline to compute data for power spectral density of Buccino's model
# takes 10 min, for 10 minutes recording

# Usage:

#     sbatch cluster/figures/main/buccino/psd/10m/psd_buttw_raw_welch.sbatch

# Description:

# - take first 10 mins
# - compress to int16 and save
# - calculate and save Welch PSD

# Returns:
#     _type_: _description_
# """

# import warnings
# warnings.simplefilter(action='ignore', category=FutureWarning)
# warnings.filterwarnings("ignore")

# import os
# import numpy as np
# import spikeinterface as si
# from concurrent.futures import ProcessPoolExecutor
# from scipy import signal
# import spikeinterface.preprocessing as spre

# # move to PROJECT PATH
# PROJ_PATH = "/gpfs/bbp.cscs.ch/project/proj85/home/laquitai/spikebias/"
# os.chdir(PROJ_PATH)

# from src.nodes.utils import get_config

# # pipeline
# COMPUTE_TRACES_IN_CTX = True
# COMPUTE_PSD = True

# # SETUP PARAMETERS
# SFREQ = 32000          # sampling frequency

# # welch PSD plots
# FILT_WINDOW = "hann"
# FILT_WIND_SIZE = 32000 # 1Hz freq. resol
# FILT_WIND_OVERLAP = int(
#     FILT_WIND_SIZE // 1.5
# )  # // 2 # overlap raises computational cost.


# # SETUP DATASET COMFIG
# data_conf_sili, param_conf_sili = get_config(
#     "buccino_2020", "2020"
# ).values()
# RAW_PATH_sili = data_conf_sili["probe_wiring"]["output"]
# PREP_PATH_sili = data_conf_sili["preprocessing"]["output"]["trace_file_path"]


# def get_welch_psd_parallelized(traces: np.ndarray):
#     """compute power spectrum density
#     using parallel computing

#     Args:
#         traces (np.ndarray): timepoints x sites voltage traces

#     Returns:
#         dict: frequencies x sites powers arraay and frequencies array
#     """
#     # takes 2 min (instead of 70 min w/o multiprocessing)
#     nsites = traces.shape[1]

#     # compute power for each site trace
#     # in parallel with a pool of workers
#     with ProcessPoolExecutor() as executor:
#         power_by_site = executor.map(
#             get_site_welch_psd,
#             traces.T,
#             np.arange(0, nsites, 1),
#         )
#     power_by_sites = list(power_by_site)

#     # make an array with powers
#     powersd = []
#     for site in range(nsites):
#         powersd.append(power_by_sites[site][0])
#     powers = np.array(powersd)

#     # store frequency domain
#     freqs = power_by_sites[0][1]
#     return {"power": powers, "freq": freqs}


# def get_site_welch_psd(trace, site):
#     """calculate the welch frequency powers in the input trace

#     Args:
#         traces (np.ndarray): timepoints x sites voltage trace
#         sfreq (_type_): voltage trace sampling frequency
#         site: silent, automatically generated by ProcessPoolExecutor()

#     Returns:
#         _type_: _description_
#     """
#     (freq, power) = signal.welch(
#         trace,
#         SFREQ,
#         window=FILT_WINDOW,
#         nperseg=FILT_WIND_SIZE,
#         noverlap=FILT_WIND_OVERLAP,
#     )
#     return np.array(power), np.array(freq)


# def save_psd_results(out_raw_sili, out_prep_sili):

#     os.makedirs(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/postprocessing/hybrid/buccino/realism/lfp/",
#         exist_ok=True,
#     )    
#     np.save(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/postprocessing/hybrid/buccino/realism/lfp/raw_power_welch_10m",
#         out_raw_sili,
#     )
#     np.save(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/postprocessing/hybrid/buccino/realism/lfp/prep_buttw_power_welch_10m",
#         out_prep_sili,
#     )


# def save_traces_in_ctx(
#     raw_traces_sili, prep_traces_sili
# ):
#     os.makedirs(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/dataeng/hybrid/buccino/recording/",
#         exist_ok=True,
#     )
#     os.makedirs(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/dataeng/hybrid/buccino/preprocessed/",
#         exist_ok=True,
#     )        
#     np.save(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/dataeng/hybrid/buccino/recording/traces_10m",
#         raw_traces_sili,
#     )
#     np.save(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/dataeng/hybrid/buccino/preprocessed/traces_10m",
#         prep_traces_sili,
#     )


# def load_saved_traces_in_ctx():

#     raw_traces_sili = np.load(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/dataeng/hybrid/buccino/recording/traces_10m",
#     )

#     prep_traces_sili = np.load(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/dataeng/hybrid/buccino/preprocessed/traces_10m",
#     )
#     return raw_traces_sili, prep_traces_sili


# def load_psd_results():

#     # raw
#     out_raw_sili = np.load(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/postprocessing/hybrid/buccino/realism/lfp/raw_power_welch_10m",
#         allow_pickle=True,
#     )
#     out_raw_sili = out_raw_sili.item()
    
#     # preprocessed
#     out_prep_sili = np.load(
#         "/gpfs/bbp.cscs.ch/project/proj85/scratch/laquitai/4_preprint_2023/postprocessing/hybrid/buccino/realism/lfp/prep_buttw_power_welch_10m",
#         allow_pickle=True,
#     )
#     out_prep_sili = out_prep_sili.item()
#     return out_raw_sili, out_prep_sili



# # load traces 
# RawSili = si.load_extractor(RAW_PATH_sili)
# PreprocessedSili = si.load_extractor(PREP_PATH_sili)

# # select the first 10 minutes
# RawSili = RawSili.frame_slice(start_frame=0, end_frame=SFREQ * 10 * 60)
# PreprocessedSili = PreprocessedSili.frame_slice(
#     start_frame=0, end_frame=SFREQ * 10 * 60
# )

# # compress from floats to integers
# RawSili = spre.astype(RawSili, "int16")
# PreprocessedSili = spre.astype(PreprocessedSili, "int16")

# # unit-test
# assert RawSili.get_total_duration() == 10 * 60, "not 10 min"

# # (17m)Compute
# if COMPUTE_TRACES_IN_CTX:

#     # keep all sites, are in L5 cortex
#     raw_traces_sili = RawSili.get_traces()

#     # preprocessed
#     prep_traces_sili = PreprocessedSili.get_traces()

#     #(1m) save
#     save_traces_in_ctx(raw_traces_sili, prep_traces_sili)

# else:
#     # or load
#     raw_traces_sili, prep_traces_sili = (
#         load_saved_traces_in_ctx()
#     )

# # (77m) Compute
# if COMPUTE_PSD:
#     # raw
#     out_raw_sili = get_welch_psd_parallelized(raw_traces_sili)

#     # preprocessed
#     out_prep_sili = get_welch_psd_parallelized(prep_traces_sili)

#     # save
#     save_psd_results(out_raw_sili, out_prep_sili)
# else:
#     # or load
#     out_raw_sili, out_prep_sili = load_psd_results()