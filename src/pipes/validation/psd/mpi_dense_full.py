
"""Computs power spectral densities of the entire
recordings with the dense probe (Horvath et al)

Usage:

    sbatch cluster/validation/psd/mpi_dense_full.sh

Returns:
    (.npy): writes power spectral densities for the experimental
    and model dense probe recordings

Execution time: 5 mins

"""

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.filterwarnings("ignore")

import os
import numpy as np
import spikeinterface as si
from concurrent.futures import ProcessPoolExecutor
import spikeinterface.preprocessing as spre
from scipy import signal
from mpi4py import MPI
import yaml
import logging
import logging.config
import time

# move to PROJECT PATH
PROJ_PATH = "/gpfs/bbp.cscs.ch/project/proj85/home/laquitai/preprint_2023/"
os.chdir(PROJ_PATH)

from src.nodes.utils import get_config, demean

# setup logging
with open("conf/logging.yml", "r", encoding="utf-8") as logging_conf:
    LOG_CONF = yaml.load(logging_conf, Loader=yaml.FullLoader)
logging.config.dictConfig(LOG_CONF)
logger = logging.getLogger("root")

# SETUP PARAMETERS
SF_HV = 20000
SF_HS = 20000

# SETUP DATASET CONFIG ******************
# Horvath (vivo)
# probe 1
cfg_hv1, _ = get_config("vivo_horvath", "probe_1").values()
RAW_PATH_HV1 = cfg_hv1["probe_wiring"]["output"]
PRE_PATH_HV1 = cfg_hv1["preprocessing"]["output"]["trace_file_path"]
RAW_PSD_PATH_HV1 = cfg_hv1["validation"]["psd"]["raw"]
PRE_PSD_PATH_HV1 = cfg_hv1["validation"]["psd"]["preprocessed"]
# probe 2
cfg_hv2, _ = get_config("vivo_horvath", "probe_2").values()
RAW_PATH_HV2 = cfg_hv2["probe_wiring"]["output"]
PRE_PATH_HV2 = cfg_hv2["preprocessing"]["output"]["trace_file_path"]
RAW_PSD_PATH_HV2 = cfg_hv2["validation"]["psd"]["raw"]
PRE_PSD_PATH_HV2 = cfg_hv2["validation"]["psd"]["preprocessed"]
# probe 3
cfg_hv3, _ = get_config("vivo_horvath", "probe_3").values()
RAW_PATH_HV3 = cfg_hv3["probe_wiring"]["output"]
PRE_PATH_HV3 = cfg_hv3["preprocessing"]["output"]["trace_file_path"]
RAW_PSD_PATH_HV3 = cfg_hv3["validation"]["psd"]["raw"]
PRE_PSD_PATH_HV3 = cfg_hv3["validation"]["psd"]["preprocessed"]

# biophy. spont.
# probe 1
cfg_hs1, _ = get_config(
    "silico_horvath", "concatenated/probe_1"
).values()
RAW_PATH_HS1 = cfg_hs1["probe_wiring"]["output"]
PRE_PATH_HS1 = cfg_hs1["preprocessing"]["output"]["trace_file_path"]
RAW_PSD_PATH_HS1 = cfg_hs1["validation"]["psd"]["raw"]
PRE_PSD_PATH_HS1 = cfg_hs1["validation"]["psd"]["preprocessed"]
# probe 2
cfg_hs2, _ = get_config(
    "silico_horvath", "concatenated/probe_2"
).values()
RAW_PATH_HS2 = cfg_hs2["probe_wiring"]["output"]
PRE_PATH_HS2 = cfg_hs2["preprocessing"]["output"]["trace_file_path"]
RAW_PSD_PATH_HS2 = cfg_hs2["validation"]["psd"]["raw"]
PRE_PSD_PATH_HS2 = cfg_hs2["validation"]["psd"]["preprocessed"]
# probe 3
cfg_hs3, _ = get_config(
    "silico_horvath", "concatenated/probe_3"
).values()
RAW_PATH_HS3 = cfg_hs3["probe_wiring"]["output"]
PRE_PATH_HS3 = cfg_hs3["preprocessing"]["output"]["trace_file_path"]
RAW_PSD_PATH_HS3 = cfg_hs3["validation"]["psd"]["raw"]
PRE_PSD_PATH_HS3 = cfg_hs3["validation"]["psd"]["preprocessed"]


# SETUP WELCH PSD PARAMETERS *******************
FILT_WINDOW = "hann"

# vivo
FILT_WIND_SIZE_HV = SF_HV # 1Hz freq. resolution
FILT_WIND_OVERLAP_HV = int(
    FILT_WIND_SIZE_HV // 1.5
)

# silico 
FILT_WIND_SIZE_HS = SF_HS # 1Hz freq. resolution
FILT_WIND_OVERLAP_HS = int(
    FILT_WIND_SIZE_HS // 1.5
)

def get_welch_psd_hs_parallelized(traces: np.ndarray):
    """compute power spectrum density for horvath Silico
    using parallel computing

    Args:
        traces (np.ndarray): timepoints x sites voltage traces

    Returns:
        dict: frequencies x sites powers arraay and frequencies array
    """
    # takes 2 min (instead of 70 min w/o multiprocessing)
    nsites = traces.shape[1]

    # compute power for each site trace
    # in parallel with a pool of workers
    with ProcessPoolExecutor() as executor:
        power_by_site = executor.map(
            get_site_welch_psd_hs,
            traces.T,
            np.arange(0, nsites, 1),
        )
    power_by_sites = list(power_by_site)

    # make an array with powers
    powersd = []
    for site in range(nsites):
        powersd.append(power_by_sites[site][0])
    powers = np.array(powersd)

    # store frequency domain
    freqs = power_by_sites[0][1]
    return {"power": powers, "freq": freqs}


def get_site_welch_psd_hs(trace, site):
    """calculate the welch frequency powers in the input trace

    Args:
        traces (np.ndarray): timepoints x sites voltage trace
        sfreq (_type_): voltage trace sampling frequency
        site: silent, automatically generated by ProcessPoolExecutor()

    Returns:
        _type_: _description_
    """
    (freq, power) = signal.welch(
        trace,
        SF_HS,
        window=FILT_WINDOW,
        nperseg=FILT_WIND_SIZE_HS,
        noverlap=FILT_WIND_OVERLAP_HS,
    )
    return np.array(power), np.array(freq)


def get_welch_psd_hv_parallelized(traces: np.ndarray):
    """compute power spectrum density for horvath Silico
    using parallel computing

    Args:
        traces (np.ndarray): timepoints x sites voltage traces

    Returns:
        dict: frequencies x sites powers arraay and frequencies array
    """
    # takes 2 min (instead of 70 min w/o multiprocessing)
    nsites = traces.shape[1]

    # compute power for each site trace
    # in parallel with a pool of workers
    with ProcessPoolExecutor() as executor:
        power_by_site = executor.map(
            get_site_welch_psd_hv,
            traces.T,
            np.arange(0, nsites, 1),
        )
    power_by_sites = list(power_by_site)

    # make an array with powers
    powersd = []
    for site in range(nsites):
        powersd.append(power_by_sites[site][0])
    powers = np.array(powersd)

    # store frequency domain
    freqs = power_by_sites[0][1]
    return {"power": powers, "freq": freqs}


def get_site_welch_psd_hv(trace, site):
    """calculate the welch frequency powers in the input trace

    Args:
        traces (np.ndarray): timepoints x sites voltage trace
        sfreq (_type_): voltage trace sampling frequency
        site: silent, automatically generated by ProcessPoolExecutor()

    Returns:
        _type_: _description_
    """
    (freq, power) = signal.welch(
        trace,
        SF_HV,
        window=FILT_WINDOW,
        nperseg=FILT_WIND_SIZE_HV,
        noverlap=FILT_WIND_OVERLAP_HV,
    )
    return np.array(power), np.array(freq)

    
def save_psd(data, write_path: str):
    parent_path = os.path.dirname(write_path)
    if not os.path.isdir(parent_path):
        os.makedirs(parent_path)
    np.save(write_path, data)
    
    
def main(rank, n_ranks):
    
    # Load datasets
    t0 = time.time()
    logger.info(f"Starting on rank {rank}")
    
    if rank == 0:
        RawHV1 = si.load_extractor(RAW_PATH_HV1)
        PreHV1 = si.load_extractor(PRE_PATH_HV1)
        #RawHV1 = RawHV1.frame_slice(start_frame=0, end_frame=SF_HV * 1*30)
        #PreHV1 = PreHV1.frame_slice(start_frame=0, end_frame=SF_HV * 1*30)
        # compress from floats to integers
        RawHV1 = spre.astype(RawHV1, "int16")
        PreHV1 = spre.astype(PreHV1, "int16")
        # select sites in cortex
        layers = ["L1", "L2_3"]
        sites_hv1 = RawHV1.get_property("layers")
        sites_hv1 = [
            "L2_3" if l_i == "L2" or l_i == "L3" else l_i for l_i in sites_hv1
        ]
        sites_hv1 = np.where(np.isin(sites_hv1, layers))[0]
        # demean
        #- Remove DC component by subtracting the mean
        raw_traces_hv1 = demean(RawHV1.get_traces()[:, sites_hv1])
        pre_traces_hv1 = demean(PreHV1.get_traces()[:, sites_hv1])
        # compute psd
        out_raw_hv1 = get_welch_psd_hv_parallelized(raw_traces_hv1)
        out_pre_hv1 = get_welch_psd_hv_parallelized(pre_traces_hv1)
        # save
        save_psd(out_raw_hv1, RAW_PSD_PATH_HV1)
        save_psd(out_pre_hv1, PRE_PSD_PATH_HV1)        
    elif rank == 1:
        RawHV2 = si.load_extractor(RAW_PATH_HV2)
        PreHV2 = si.load_extractor(PRE_PATH_HV2)
        #RawHV2 = RawHV2.frame_slice(start_frame=0, end_frame=SF_HV * 1*30)
        #PreHV2 = PreHV2.frame_slice(start_frame=0, end_frame=SF_HV * 1*30)
        # compress from floats to integers
        RawHV2 = spre.astype(RawHV2, "int16")
        PreHV2 = spre.astype(PreHV2, "int16")
        # select sites in cortex
        layers = ["L4", "L5"]
        sites_hv2 = RawHV2.get_property("layers")
        sites_hv2 = np.where(np.isin(sites_hv2, layers))[0]
        # demean
        #- Remove DC component by subtracting the mean
        raw_traces_hv2 = demean(RawHV2.get_traces()[:, sites_hv2])
        pre_traces_hv2 = demean(PreHV2.get_traces()[:, sites_hv2])
        # compute psd
        out_raw_hv2 = get_welch_psd_hv_parallelized(raw_traces_hv2)
        out_pre_hv2 = get_welch_psd_hv_parallelized(pre_traces_hv2) 
        # save
        save_psd(out_raw_hv2, RAW_PSD_PATH_HV2)
        save_psd(out_pre_hv2, PRE_PSD_PATH_HV2)
    elif rank==2:
        RawHV3 = si.load_extractor(RAW_PATH_HV3)
        PreHV3 = si.load_extractor(PRE_PATH_HV3)
        #RawHV3 = RawHV3.frame_slice(start_frame=0, end_frame=SF_HV * 1*30)
        #PreHV3 = PreHV3.frame_slice(start_frame=0, end_frame=SF_HV * 1*30)
        # compress from floats to integers
        RawHV3 = spre.astype(RawHV3, "int16")
        PreHV3 = spre.astype(PreHV3, "int16")
        # select sites in cortex
        layers = ["L6"]
        sites_hv3 = RawHV3.get_property("layers")
        sites_hv3 = np.where(np.isin(sites_hv3, layers))[0]
        # demean
        #- Remove DC component by subtracting the mean
        raw_traces_hv3 = demean(RawHV3.get_traces()[:, sites_hv3])
        pre_traces_hv3 = demean(PreHV3.get_traces()[:, sites_hv3])
        # compute psd
        out_raw_hv3 = get_welch_psd_hv_parallelized(raw_traces_hv3)
        out_pre_hv3 = get_welch_psd_hv_parallelized(pre_traces_hv3)
        # save
        save_psd(out_raw_hv3, RAW_PSD_PATH_HV3)
        save_psd(out_pre_hv3, PRE_PSD_PATH_HV3)
    elif rank==3:
        RawHS1 = si.load_extractor(RAW_PATH_HS1)
        PreHS1 = si.load_extractor(PRE_PATH_HS1)
        #RawHS1 = RawHS1.frame_slice(start_frame=0, end_frame=SF_HS * 1*30)
        #PreHS1 = PreHS1.frame_slice(start_frame=0, end_frame=SF_HS * 1*30)
        # compress from floats to integers
        RawHS1 = spre.astype(RawHS1, "int16")
        PreHS1 = spre.astype(PreHS1, "int16")
        # select sites in cortex
        layers = ["L1", "L2_3"]
        sites_hs1 = RawHS1.get_property("layers")
        sites_hs1 = [
            "L2_3" if l_i == "L2" or l_i == "L3" else l_i for l_i in sites_hs1
        ]
        sites_hs1 = np.where(np.isin(sites_hs1, layers))[0]
        # demean
        #- Remove DC component by subtracting the mean
        raw_traces_hs1 = demean(RawHS1.get_traces()[:, sites_hs1])
        pre_traces_hs1 = demean(PreHS1.get_traces()[:, sites_hs1])
        # compute psd
        out_raw_hs1 = get_welch_psd_hv_parallelized(raw_traces_hs1)
        out_pre_hs1 = get_welch_psd_hv_parallelized(pre_traces_hs1)
        # save
        save_psd(out_raw_hs1, RAW_PSD_PATH_HS1)
        save_psd(out_pre_hs1, PRE_PSD_PATH_HS1)
    elif rank==4:
        RawHS2 = si.load_extractor(RAW_PATH_HS2)
        PreHS2 = si.load_extractor(PRE_PATH_HS2)
        #RawHS2 = RawHS2.frame_slice(start_frame=0, end_frame=SF_HS * 1*30)
        #PreHS2 = PreHS2.frame_slice(start_frame=0, end_frame=SF_HS * 1*30)
        # compress from floats to integers
        RawHS2 = spre.astype(RawHS2, "int16")
        PreHS2 = spre.astype(PreHS2, "int16")
        # select sites in cortex
        layers = ["L4", "L5"]
        sites_hs2 = RawHS2.get_property("layers")
        sites_hs2 = np.where(np.isin(sites_hs2, layers))[0]
        # demean
        #- Remove DC component by subtracting the mean
        raw_traces_hs2 = demean(RawHS2.get_traces()[:, sites_hs2])
        pre_traces_hs2 = demean(PreHS2.get_traces()[:, sites_hs2])
        # compute psd
        out_raw_hs2 = get_welch_psd_hv_parallelized(raw_traces_hs2)
        out_pre_hs2 = get_welch_psd_hv_parallelized(pre_traces_hs2)    
        # save
        save_psd(out_raw_hs2, RAW_PSD_PATH_HS2)
        save_psd(out_pre_hs2, PRE_PSD_PATH_HS2)
    elif rank==5:
        RawHS3 = si.load_extractor(RAW_PATH_HS3)
        PreHS3 = si.load_extractor(PRE_PATH_HS3)
        #RawHS3 = RawHS3.frame_slice(start_frame=0, end_frame=SF_HS * 1*30)
        #PreHS3 = PreHS3.frame_slice(start_frame=0, end_frame=SF_HS * 1*30)
        # compress from floats to integers
        RawHS3 = spre.astype(RawHS3, "int16")
        PreHS3 = spre.astype(PreHS3, "int16")
        # select sites in cortex
        layers = ["L6"]
        sites_hs3 = RawHS3.get_property("layers")
        sites_hs3 = np.where(np.isin(sites_hs3, layers))[0]
        # demean
        #- Remove DC component by subtracting the mean
        raw_traces_hs3 = demean(RawHS3.get_traces()[:, sites_hs3])
        pre_traces_hs3 = demean(PreHS3.get_traces()[:, sites_hs3])
        # compute psd
        out_raw_hs3 = get_welch_psd_hv_parallelized(raw_traces_hs3)
        out_pre_hs3 = get_welch_psd_hv_parallelized(pre_traces_hs3)
        # save
        save_psd(out_raw_hs3, RAW_PSD_PATH_HS3)
        save_psd(out_pre_hs3, PRE_PSD_PATH_HS3)
        
    logger.info(f"Completed on rank {rank} in {np.round(time.time()-t0,2)} secs")
    logger.info("PSD data written.")

# run
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
n_ranks = comm.Get_size()
main(rank, n_ranks)