"""Nodes to power spectral densities for the neuropixels demo dataset

Method:

* Buttwerworth temporal filtering
* Welch method for PSD
"""

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.filterwarnings("ignore")
import os
import numpy as np
import spikeinterface as si
from concurrent.futures import ProcessPoolExecutor
import spikeinterface.preprocessing as spre
from scipy import signal

# PARAMETERS 
SF_NS = 40000  # sampling frequency Biophy. spontaneous
SF_NE = 20000  # sampling frequency Biophy. evoked
FILT_WINDOW = "hann" # WELCH PSD PARAMETERS

# neuropixels (Biophy. spontaneous)
FILT_WIND_NS = 40000 # 1Hz resolution
FILT_OVERL_NS = int(
    FILT_WIND_NS // 1.5
)

# neuropixels (Biophy. evoked)
FILT_WIND_NE = 20000 # 1Hz resolution
FILT_OVERL_NE = int(
    FILT_WIND_NE // 1.5
)


def get_welch_psd_marques_silico_parallelized(traces: np.ndarray):
    """compute power spectrum density for Marques Silico
    using parallel computing

    Args:
        traces (np.ndarray): timepoints x sites voltage traces

    Returns:
        dict: frequencies x sites powers arraay and frequencies array
    """
    # takes 2 min (instead of 70 min w/o multiprocessing)
    nsites = traces.shape[1]

    # compute power for each site trace
    # in parallel with a pool of workers
    with ProcessPoolExecutor() as executor:
        power_by_site = executor.map(
            get_site_welch_psd_marques_silico,
            traces.T,
            np.arange(0, nsites, 1),
        )
    power_by_sites = list(power_by_site)

    # make an array with powers
    powersd = []
    for site in range(nsites):
        powersd.append(power_by_sites[site][0])
    powers = np.array(powersd)

    # store frequency domain
    freqs = power_by_sites[0][1]
    return {"power": powers, "freq": freqs}


def get_welch_psd_ne_parallelized(traces: np.ndarray):
    """compute power spectrum density for neuropixels Biophysical model
    in the evoked condition using parallel computing

    Args:
        traces (np.ndarray): timepoints x sites voltage traces

    Returns:
        dict: frequencies x sites powers array and frequencies array
        
    note: we typically use 72 cores
    """
    # takes 2 min (instead of 70 min w/o multiprocessing)
    nsites = traces.shape[1]

    # compute power for each site trace
    # in parallel with a pool of workers
    with ProcessPoolExecutor() as executor:
        power_by_site = executor.map(
            get_site_welch_psd_ne,
            traces.T,
            np.arange(0, nsites, 1),
        )
    power_by_sites = list(power_by_site)

    # make an array with powers
    powersd = []
    for site in range(nsites):
        powersd.append(power_by_sites[site][0])
    powers = np.array(powersd)

    # store frequency domain
    freqs = power_by_sites[0][1]
    return {"power": powers, "freq": freqs}


def get_site_welch_psd_marques_silico(trace, site):
    """calculate the welch frequency powers contained in 
    the voltage traces of the Marques-Smith's in vivo dataset

    Args:
        traces (np.ndarray): timepoints x sites voltage trace
        sfreq (_type_): voltage trace sampling frequency
        site: silent, automatically generated by ProcessPoolExecutor()

    Returns:
        _type_: _description_
    """
    (freq, power) = signal.welch(
        trace,
        SF_NS,
        window=FILT_WINDOW,
        nperseg=FILT_WIND_NS,
        noverlap=FILT_OVERL_NS,
    )
    return np.array(power), np.array(freq)


def get_site_welch_psd_ne(trace, site):
    """calculate the welch frequency powers in the input trace
    for the biophysical model in the evoked condition

    Args:
        traces (np.ndarray): timepoints x sites voltage trace
        sfreq (_type_): voltage trace sampling frequency
        site: silent, automatically generated by ProcessPoolExecutor()

    Returns:
        _type_: _description_
    """
    (freq, power) = signal.welch(
        trace,
        SF_NE,
        window=FILT_WINDOW,
        nperseg=FILT_WIND_NE,
        noverlap=FILT_OVERL_NE,
    )
    return np.array(power), np.array(freq)
